"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

require("colors");

var _asyncOra = require("@electron-forge/async-ora");

var _get = require("@electron/get");

var _makerBase = _interopRequireDefault(require("@electron-forge/maker-base"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _forgeConfig = _interopRequireDefault(require("../util/forge-config"));

var _hook = require("../util/hook");

var _messages = require("../util/messages");

var _parseArchs = _interopRequireDefault(require("../util/parse-archs"));

var _readPackageJson = require("../util/read-package-json");

var _resolveDir = _interopRequireDefault(require("../util/resolve-dir"));

var _outDir = _interopRequireDefault(require("../util/out-dir"));

var _electronVersion = require("../util/electron-version");

var _requireSearch = _interopRequireDefault(require("../util/require-search"));

var _package = _interopRequireDefault(require("./package"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class MakerImpl extends _makerBase.default {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "name", 'impl');

    _defineProperty(this, "defaultPlatforms", []);
  }

}

var _default = async ({
  dir = process.cwd(),
  interactive = false,
  skipPackage = false,
  arch = (0, _get.getHostArch)(),
  platform = process.platform,
  overrideTargets,
  outDir
}) => {
  _asyncOra.asyncOra.interactive = interactive;
  let forgeConfig;
  await (0, _asyncOra.asyncOra)('Resolving Forge Config', async () => {
    const resolvedDir = await (0, _resolveDir.default)(dir);

    if (!resolvedDir) {
      throw new Error('Failed to locate makeable Electron application');
    }

    dir = resolvedDir;
    forgeConfig = await (0, _forgeConfig.default)(dir);
  });
  const actualOutDir = outDir || (0, _outDir.default)(dir, forgeConfig);
  const actualTargetPlatform = platform;
  platform = platform === 'mas' ? 'darwin' : platform;

  if (!['darwin', 'win32', 'linux', 'mas'].includes(actualTargetPlatform)) {
    throw new Error(`'${actualTargetPlatform}' is an invalid platform. Choices are 'darwin', 'mas', 'win32' or 'linux'`);
  }

  const makers = {};
  let targets = (overrideTargets || forgeConfig.makers).map(target => {
    if (typeof target === 'string') {
      return {
        name: target
      };
    }

    return target;
  });
  let targetId = 0;

  for (const target of targets) {
    let maker; // eslint-disable-next-line no-underscore-dangle

    if (target.__isElectronForgeMaker) {
      maker = target; // eslint-disable-next-line no-continue

      if (!maker.platforms.includes(actualTargetPlatform)) continue;
    } else {
      const resolvableTarget = target;
      const MakerClass = (0, _requireSearch.default)(dir, [resolvableTarget.name]);

      if (!MakerClass) {
        throw new Error(`Could not find module with name: ${resolvableTarget.name}. Make sure it's listed in the devDependencies of your package.json`);
      }

      maker = new MakerClass(resolvableTarget.config, resolvableTarget.platforms || undefined); // eslint-disable-next-line no-continue

      if (!maker.platforms.includes(actualTargetPlatform)) continue;
    }

    if (!maker.isSupportedOnCurrentPlatform) {
      throw new Error([`Maker for target ${maker.name} is incompatible with this version of `, 'electron-forge, please upgrade or contact the maintainer ', '(needs to implement \'isSupportedOnCurrentPlatform)\')'].join(''));
    }

    if (!(await maker.isSupportedOnCurrentPlatform())) {
      throw new Error([`Cannot make for ${platform} and target ${maker.name}: the maker declared `, `that it cannot run on ${process.platform}`].join(''));
    }

    maker.ensureExternalBinariesExist();
    makers[targetId] = maker;
    targetId += 1;
  }

  if (!skipPackage) {
    (0, _messages.info)(interactive, 'We need to package your application before we can make it'.green);
    await (0, _package.default)({
      dir,
      interactive,
      arch,
      outDir: actualOutDir,
      platform: actualTargetPlatform
    });
  } else {
    (0, _messages.warn)(interactive, 'WARNING: Skipping the packaging step, this could result in an out of date build'.red);
  }

  targets = targets.filter((_, i) => makers[i]);

  if (targets.length === 0) {
    throw new Error(`Could not find any make targets configured for the "${actualTargetPlatform}" platform.`);
  }

  (0, _messages.info)(interactive, `Making for the following targets: ${`${targets.map((t, i) => makers[i].name).join(', ')}`.cyan}`);
  const packageJSON = await (0, _readPackageJson.readMutatedPackageJson)(dir, forgeConfig);
  const appName = forgeConfig.packagerConfig.name || packageJSON.productName || packageJSON.name;
  const outputs = [];
  await (0, _hook.runHook)(forgeConfig, 'preMake');

  for (const targetArch of (0, _parseArchs.default)(platform, arch, (await (0, _electronVersion.getElectronVersion)(dir, packageJSON)))) {
    const packageDir = _path.default.resolve(actualOutDir, `${appName}-${actualTargetPlatform}-${targetArch}`);

    if (!(await _fsExtra.default.pathExists(packageDir))) {
      throw new Error(`Couldn't find packaged app at: ${packageDir}`);
    }

    targetId = 0; // eslint-disable-next-line no-underscore-dangle, @typescript-eslint/no-unused-vars

    for (const _target of targets) {
      const maker = makers[targetId];
      targetId += 1; // eslint-disable-next-line no-loop-func

      await (0, _asyncOra.asyncOra)(`Making for target: ${maker.name.green} - On platform: ${actualTargetPlatform.cyan} - For arch: ${targetArch.cyan}`, async () => {
        try {
          /**
           * WARNING: DO NOT ATTEMPT TO PARALLELIZE MAKERS
           *
           * Currently it is assumed we have 1 maker per make call but that is
           * not enforced.  It is technically possible to have 1 maker be called
           * multiple times.  The "prepareConfig" method however implicitly
           * requires a lock that is not enforced.  There are two options:
           *
           *   * Provide makers a getConfig() method
           *   * Remove support for config being provided as a method
           *   * Change the entire API of maker from a single constructor to
           *     providing a MakerFactory
           */
          maker.prepareConfig(targetArch);
          const artifacts = await maker.make({
            appName,
            forgeConfig,
            packageJSON,
            targetArch,
            dir: packageDir,
            makeDir: _path.default.resolve(actualOutDir, 'make'),
            targetPlatform: actualTargetPlatform
          });
          outputs.push({
            artifacts,
            packageJSON,
            platform: actualTargetPlatform,
            arch: targetArch
          });
        } catch (err) {
          if (err) {
            // eslint-disable-next-line no-throw-literal
            throw {
              message: `An error occured while making for target: ${maker.name}`,
              stack: `${err.message}\n${err.stack}`
            };
          } else {
            throw new Error(`An unknown error occured while making for target: ${maker.name}`);
          }
        }
      });
    }
  } // If the postMake hooks modifies the locations / names of the outputs it must return
  // the new locations so that the publish step knows where to look


  return (0, _hook.runMutatingHook)(forgeConfig, 'postMake', outputs);
};

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hcGkvbWFrZS50cyJdLCJuYW1lcyI6WyJNYWtlckltcGwiLCJNYWtlckJhc2UiLCJkaXIiLCJwcm9jZXNzIiwiY3dkIiwiaW50ZXJhY3RpdmUiLCJza2lwUGFja2FnZSIsImFyY2giLCJwbGF0Zm9ybSIsIm92ZXJyaWRlVGFyZ2V0cyIsIm91dERpciIsImFzeW5jT3JhIiwiZm9yZ2VDb25maWciLCJyZXNvbHZlZERpciIsIkVycm9yIiwiYWN0dWFsT3V0RGlyIiwiYWN0dWFsVGFyZ2V0UGxhdGZvcm0iLCJpbmNsdWRlcyIsIm1ha2VycyIsInRhcmdldHMiLCJtYXAiLCJ0YXJnZXQiLCJuYW1lIiwidGFyZ2V0SWQiLCJtYWtlciIsIl9faXNFbGVjdHJvbkZvcmdlTWFrZXIiLCJwbGF0Zm9ybXMiLCJyZXNvbHZhYmxlVGFyZ2V0IiwiTWFrZXJDbGFzcyIsImNvbmZpZyIsInVuZGVmaW5lZCIsImlzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0iLCJqb2luIiwiZW5zdXJlRXh0ZXJuYWxCaW5hcmllc0V4aXN0IiwiZ3JlZW4iLCJyZWQiLCJmaWx0ZXIiLCJfIiwiaSIsImxlbmd0aCIsInQiLCJjeWFuIiwicGFja2FnZUpTT04iLCJhcHBOYW1lIiwicGFja2FnZXJDb25maWciLCJwcm9kdWN0TmFtZSIsIm91dHB1dHMiLCJ0YXJnZXRBcmNoIiwicGFja2FnZURpciIsInBhdGgiLCJyZXNvbHZlIiwiZnMiLCJwYXRoRXhpc3RzIiwiX3RhcmdldCIsInByZXBhcmVDb25maWciLCJhcnRpZmFjdHMiLCJtYWtlIiwibWFrZURpciIsInRhcmdldFBsYXRmb3JtIiwicHVzaCIsImVyciIsIm1lc3NhZ2UiLCJzdGFjayJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBSUE7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7Ozs7OztBQUVBLE1B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QVcscURBQW9EVSxLQUFLLENBQUNGLElBQUssRUFBMUUsQ0FBTjtBQUNEO0FBQ0Y7QUFDRixPQTNDSyxDQUFOO0FBNENEO0FBQ0YsR0E5SmdCLENBZ0tqQjtBQUNBOzs7QUFDQSxTQUFPLDJCQUFnQlYsV0FBaEIsRUFBNkIsVUFBN0IsRUFBeUNrQyxPQUF6QyxDQUFQO0FBQ0QsQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnY29sb3JzJztcbmltcG9ydCB7IGFzeW5jT3JhIH0gZnJvbSAnQGVsZWN0cm9uLWZvcmdlL2FzeW5jLW9yYSc7XG5pbXBvcnQgeyBnZXRIb3N0QXJjaCB9IGZyb20gJ0BlbGVjdHJvbi9nZXQnO1xuaW1wb3J0IHtcbiAgSUZvcmdlUmVzb2x2YWJsZU1ha2VyLCBGb3JnZUNvbmZpZywgRm9yZ2VBcmNoLCBGb3JnZVBsYXRmb3JtLCBGb3JnZU1ha2VSZXN1bHQsXG59IGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9zaGFyZWQtdHlwZXMnO1xuaW1wb3J0IE1ha2VyQmFzZSBmcm9tICdAZWxlY3Ryb24tZm9yZ2UvbWFrZXItYmFzZSc7XG5pbXBvcnQgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5cbmltcG9ydCBnZXRGb3JnZUNvbmZpZyBmcm9tICcuLi91dGlsL2ZvcmdlLWNvbmZpZyc7XG5pbXBvcnQgeyBydW5Ib29rLCBydW5NdXRhdGluZ0hvb2sgfSBmcm9tICcuLi91dGlsL2hvb2snO1xuaW1wb3J0IHsgaW5mbywgd2FybiB9IGZyb20gJy4uL3V0aWwvbWVzc2FnZXMnO1xuaW1wb3J0IHBhcnNlQXJjaHMgZnJvbSAnLi4vdXRpbC9wYXJzZS1hcmNocyc7XG5pbXBvcnQgeyByZWFkTXV0YXRlZFBhY2thZ2VKc29uIH0gZnJvbSAnLi4vdXRpbC9yZWFkLXBhY2thZ2UtanNvbic7XG5pbXBvcnQgcmVzb2x2ZURpciBmcm9tICcuLi91dGlsL3Jlc29sdmUtZGlyJztcbmltcG9ydCBnZXRDdXJyZW50T3V0RGlyIGZyb20gJy4uL3V0aWwvb3V0LWRpcic7XG5pbXBvcnQgeyBnZXRFbGVjdHJvblZlcnNpb24gfSBmcm9tICcuLi91dGlsL2VsZWN0cm9uLXZlcnNpb24nO1xuaW1wb3J0IHJlcXVpcmVTZWFyY2ggZnJvbSAnLi4vdXRpbC9yZXF1aXJlLXNlYXJjaCc7XG5cbmltcG9ydCBwYWNrYWdlciBmcm9tICcuL3BhY2thZ2UnO1xuXG5jbGFzcyBNYWtlckltcGwgZXh0ZW5kcyBNYWtlckJhc2U8YW55PiB7XG4gIG5hbWUgPSAnaW1wbCc7XG5cbiAgZGVmYXVsdFBsYXRmb3JtcyA9IFtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1ha2VPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBwYXRoIHRvIHRoZSBhcHAgZnJvbSB3aGljaCBkaXN0cnVidXRhYmxlcyBhcmUgZ2VuZXJhdGVkXG4gICAqL1xuICBkaXI/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHVzZSBzZW5zaWJsZSBkZWZhdWx0cyBvciBwcm9tcHQgdGhlIHVzZXIgdmlzdWFsbHlcbiAgICovXG4gIGludGVyYWN0aXZlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc2tpcCB0aGUgcHJlLW1ha2UgcGFja2FnaW5nIHN0ZXBcbiAgICovXG4gIHNraXBQYWNrYWdlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIG1ha2UgdGFyZ2V0cyB0byBvdmVycmlkZSB5b3VyIGZvcmdlIGNvbmZpZ1xuICAgKi9cbiAgb3ZlcnJpZGVUYXJnZXRzPzogKElGb3JnZVJlc29sdmFibGVNYWtlciB8IE1ha2VyQmFzZTxhbnk+KVtdO1xuICAvKipcbiAgICogVGhlIHRhcmdldCBhcmNoaXRlY3R1cmVcbiAgICovXG4gIGFyY2g/OiBGb3JnZUFyY2g7XG4gIC8qKlxuICAgKiBUaGUgdGFyZ2V0IHBsYXRmb3JtXG4gICAqL1xuICBwbGF0Zm9ybT86IEZvcmdlUGxhdGZvcm07XG4gIC8qKlxuICAgKiBUaGUgcGF0aCB0byB0aGUgZGlyZWN0b3J5IGNvbnRhaW5pbmcgZ2VuZXJhdGVkIGRpc3RyaWJ1dGFibGVzXG4gICAqL1xuICBvdXREaXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jICh7XG4gIGRpciA9IHByb2Nlc3MuY3dkKCksXG4gIGludGVyYWN0aXZlID0gZmFsc2UsXG4gIHNraXBQYWNrYWdlID0gZmFsc2UsXG4gIGFyY2ggPSBnZXRIb3N0QXJjaCgpIGFzIEZvcmdlQXJjaCxcbiAgcGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtIGFzIEZvcmdlUGxhdGZvcm0sXG4gIG92ZXJyaWRlVGFyZ2V0cyxcbiAgb3V0RGlyLFxufTogTWFrZU9wdGlvbnMpID0+IHtcbiAgYXN5bmNPcmEuaW50ZXJhY3RpdmUgPSBpbnRlcmFjdGl2ZTtcblxuICBsZXQgZm9yZ2VDb25maWchOiBGb3JnZUNvbmZpZztcbiAgYXdhaXQgYXN5bmNPcmEoJ1Jlc29sdmluZyBGb3JnZSBDb25maWcnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzb2x2ZWREaXIgPSBhd2FpdCByZXNvbHZlRGlyKGRpcik7XG4gICAgaWYgKCFyZXNvbHZlZERpcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbG9jYXRlIG1ha2VhYmxlIEVsZWN0cm9uIGFwcGxpY2F0aW9uJyk7XG4gICAgfVxuICAgIGRpciA9IHJlc29sdmVkRGlyO1xuXG4gICAgZm9yZ2VDb25maWcgPSBhd2FpdCBnZXRGb3JnZUNvbmZpZyhkaXIpO1xuICB9KTtcblxuICBjb25zdCBhY3R1YWxPdXREaXIgPSBvdXREaXIgfHwgZ2V0Q3VycmVudE91dERpcihkaXIsIGZvcmdlQ29uZmlnKTtcblxuICBjb25zdCBhY3R1YWxUYXJnZXRQbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICBwbGF0Zm9ybSA9IHBsYXRmb3JtID09PSAnbWFzJyA/ICdkYXJ3aW4nIDogcGxhdGZvcm07XG4gIGlmICghWydkYXJ3aW4nLCAnd2luMzInLCAnbGludXgnLCAnbWFzJ10uaW5jbHVkZXMoYWN0dWFsVGFyZ2V0UGxhdGZvcm0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAnJHthY3R1YWxUYXJnZXRQbGF0Zm9ybX0nIGlzIGFuIGludmFsaWQgcGxhdGZvcm0uIENob2ljZXMgYXJlICdkYXJ3aW4nLCAnbWFzJywgJ3dpbjMyJyBvciAnbGludXgnYCk7XG4gIH1cblxuICBjb25zdCBtYWtlcnM6IHtcbiAgICBba2V5OiBudW1iZXJdOiBNYWtlckJhc2U8YW55PjtcbiAgfSA9IHt9O1xuICBsZXQgdGFyZ2V0cyA9IChvdmVycmlkZVRhcmdldHMgfHwgZm9yZ2VDb25maWcubWFrZXJzKS5tYXAoKHRhcmdldCkgPT4ge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHsgbmFtZTogdGFyZ2V0IH07XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH0pO1xuXG4gIGxldCB0YXJnZXRJZCA9IDA7XG4gIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICBsZXQgbWFrZXI6IE1ha2VyQmFzZTxhbnk+O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgIGlmICgodGFyZ2V0IGFzIE1ha2VyQmFzZTxhbnk+KS5fX2lzRWxlY3Ryb25Gb3JnZU1ha2VyKSB7XG4gICAgICBtYWtlciA9IHRhcmdldCBhcyBNYWtlckJhc2U8YW55PjtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgaWYgKCFtYWtlci5wbGF0Zm9ybXMuaW5jbHVkZXMoYWN0dWFsVGFyZ2V0UGxhdGZvcm0pKSBjb250aW51ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVzb2x2YWJsZVRhcmdldDogSUZvcmdlUmVzb2x2YWJsZU1ha2VyID0gdGFyZ2V0IGFzIElGb3JnZVJlc29sdmFibGVNYWtlcjtcbiAgICAgIGNvbnN0IE1ha2VyQ2xhc3MgPSByZXF1aXJlU2VhcmNoPHR5cGVvZiBNYWtlckltcGw+KGRpciwgW3Jlc29sdmFibGVUYXJnZXQubmFtZV0pO1xuICAgICAgaWYgKCFNYWtlckNsYXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgbW9kdWxlIHdpdGggbmFtZTogJHtyZXNvbHZhYmxlVGFyZ2V0Lm5hbWV9LiBNYWtlIHN1cmUgaXQncyBsaXN0ZWQgaW4gdGhlIGRldkRlcGVuZGVuY2llcyBvZiB5b3VyIHBhY2thZ2UuanNvbmApO1xuICAgICAgfVxuXG4gICAgICBtYWtlciA9IG5ldyBNYWtlckNsYXNzKHJlc29sdmFibGVUYXJnZXQuY29uZmlnLCByZXNvbHZhYmxlVGFyZ2V0LnBsYXRmb3JtcyB8fCB1bmRlZmluZWQpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICBpZiAoIW1ha2VyLnBsYXRmb3Jtcy5pbmNsdWRlcyhhY3R1YWxUYXJnZXRQbGF0Zm9ybSkpIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICghbWFrZXIuaXNTdXBwb3J0ZWRPbkN1cnJlbnRQbGF0Zm9ybSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICAgICAgYE1ha2VyIGZvciB0YXJnZXQgJHttYWtlci5uYW1lfSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGlzIHZlcnNpb24gb2YgYCxcbiAgICAgICAgJ2VsZWN0cm9uLWZvcmdlLCBwbGVhc2UgdXBncmFkZSBvciBjb250YWN0IHRoZSBtYWludGFpbmVyICcsXG4gICAgICAgICcobmVlZHMgdG8gaW1wbGVtZW50IFxcJ2lzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0pXFwnKScsXG4gICAgICBdLmpvaW4oJycpKTtcbiAgICB9XG5cbiAgICBpZiAoIWF3YWl0IG1ha2VyLmlzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0oKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICAgICAgYENhbm5vdCBtYWtlIGZvciAke3BsYXRmb3JtfSBhbmQgdGFyZ2V0ICR7bWFrZXIubmFtZX06IHRoZSBtYWtlciBkZWNsYXJlZCBgLFxuICAgICAgICBgdGhhdCBpdCBjYW5ub3QgcnVuIG9uICR7cHJvY2Vzcy5wbGF0Zm9ybX1gLFxuICAgICAgXS5qb2luKCcnKSk7XG4gICAgfVxuXG4gICAgbWFrZXIuZW5zdXJlRXh0ZXJuYWxCaW5hcmllc0V4aXN0KCk7XG5cbiAgICBtYWtlcnNbdGFyZ2V0SWRdID0gbWFrZXI7XG4gICAgdGFyZ2V0SWQgKz0gMTtcbiAgfVxuXG4gIGlmICghc2tpcFBhY2thZ2UpIHtcbiAgICBpbmZvKGludGVyYWN0aXZlLCAnV2UgbmVlZCB0byBwYWNrYWdlIHlvdXIgYXBwbGljYXRpb24gYmVmb3JlIHdlIGNhbiBtYWtlIGl0Jy5ncmVlbik7XG4gICAgYXdhaXQgcGFja2FnZXIoe1xuICAgICAgZGlyLFxuICAgICAgaW50ZXJhY3RpdmUsXG4gICAgICBhcmNoLFxuICAgICAgb3V0RGlyOiBhY3R1YWxPdXREaXIsXG4gICAgICBwbGF0Zm9ybTogYWN0dWFsVGFyZ2V0UGxhdGZvcm0sXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgd2FybihpbnRlcmFjdGl2ZSwgJ1dBUk5JTkc6IFNraXBwaW5nIHRoZSBwYWNrYWdpbmcgc3RlcCwgdGhpcyBjb3VsZCByZXN1bHQgaW4gYW4gb3V0IG9mIGRhdGUgYnVpbGQnLnJlZCk7XG4gIH1cblxuICB0YXJnZXRzID0gdGFyZ2V0cy5maWx0ZXIoKF8sIGkpID0+IG1ha2Vyc1tpXSk7XG5cbiAgaWYgKHRhcmdldHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBhbnkgbWFrZSB0YXJnZXRzIGNvbmZpZ3VyZWQgZm9yIHRoZSBcIiR7YWN0dWFsVGFyZ2V0UGxhdGZvcm19XCIgcGxhdGZvcm0uYCk7XG4gIH1cblxuICBpbmZvKGludGVyYWN0aXZlLCBgTWFraW5nIGZvciB0aGUgZm9sbG93aW5nIHRhcmdldHM6ICR7YCR7dGFyZ2V0cy5tYXAoKHQsIGkpID0+IG1ha2Vyc1tpXS5uYW1lKS5qb2luKCcsICcpfWAuY3lhbn1gKTtcblxuICBjb25zdCBwYWNrYWdlSlNPTiA9IGF3YWl0IHJlYWRNdXRhdGVkUGFja2FnZUpzb24oZGlyLCBmb3JnZUNvbmZpZyk7XG4gIGNvbnN0IGFwcE5hbWUgPSBmb3JnZUNvbmZpZy5wYWNrYWdlckNvbmZpZy5uYW1lIHx8IHBhY2thZ2VKU09OLnByb2R1Y3ROYW1lIHx8IHBhY2thZ2VKU09OLm5hbWU7XG4gIGNvbnN0IG91dHB1dHM6IEZvcmdlTWFrZVJlc3VsdFtdID0gW107XG5cbiAgYXdhaXQgcnVuSG9vayhmb3JnZUNvbmZpZywgJ3ByZU1ha2UnKTtcblxuICBmb3IgKGNvbnN0IHRhcmdldEFyY2ggb2YgcGFyc2VBcmNocyhwbGF0Zm9ybSwgYXJjaCwgYXdhaXQgZ2V0RWxlY3Ryb25WZXJzaW9uKGRpciwgcGFja2FnZUpTT04pKSkge1xuICAgIGNvbnN0IHBhY2thZ2VEaXIgPSBwYXRoLnJlc29sdmUoYWN0dWFsT3V0RGlyLCBgJHthcHBOYW1lfS0ke2FjdHVhbFRhcmdldFBsYXRmb3JtfS0ke3RhcmdldEFyY2h9YCk7XG4gICAgaWYgKCEoYXdhaXQgZnMucGF0aEV4aXN0cyhwYWNrYWdlRGlyKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGRuJ3QgZmluZCBwYWNrYWdlZCBhcHAgYXQ6ICR7cGFja2FnZURpcn1gKTtcbiAgICB9XG5cbiAgICB0YXJnZXRJZCA9IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBmb3IgKGNvbnN0IF90YXJnZXQgb2YgdGFyZ2V0cykge1xuICAgICAgY29uc3QgbWFrZXIgPSBtYWtlcnNbdGFyZ2V0SWRdO1xuICAgICAgdGFyZ2V0SWQgKz0gMTtcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvb3AtZnVuY1xuICAgICAgYXdhaXQgYXN5bmNPcmEoYE1ha2luZyBmb3IgdGFyZ2V0OiAke21ha2VyLm5hbWUuZ3JlZW59IC0gT24gcGxhdGZvcm06ICR7YWN0dWFsVGFyZ2V0UGxhdGZvcm0uY3lhbn0gLSBGb3IgYXJjaDogJHt0YXJnZXRBcmNoLmN5YW59YCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFdBUk5JTkc6IERPIE5PVCBBVFRFTVBUIFRPIFBBUkFMTEVMSVpFIE1BS0VSU1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogQ3VycmVudGx5IGl0IGlzIGFzc3VtZWQgd2UgaGF2ZSAxIG1ha2VyIHBlciBtYWtlIGNhbGwgYnV0IHRoYXQgaXNcbiAgICAgICAgICAgKiBub3QgZW5mb3JjZWQuICBJdCBpcyB0ZWNobmljYWxseSBwb3NzaWJsZSB0byBoYXZlIDEgbWFrZXIgYmUgY2FsbGVkXG4gICAgICAgICAgICogbXVsdGlwbGUgdGltZXMuICBUaGUgXCJwcmVwYXJlQ29uZmlnXCIgbWV0aG9kIGhvd2V2ZXIgaW1wbGljaXRseVxuICAgICAgICAgICAqIHJlcXVpcmVzIGEgbG9jayB0aGF0IGlzIG5vdCBlbmZvcmNlZC4gIFRoZXJlIGFyZSB0d28gb3B0aW9uczpcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqICAgKiBQcm92aWRlIG1ha2VycyBhIGdldENvbmZpZygpIG1ldGhvZFxuICAgICAgICAgICAqICAgKiBSZW1vdmUgc3VwcG9ydCBmb3IgY29uZmlnIGJlaW5nIHByb3ZpZGVkIGFzIGEgbWV0aG9kXG4gICAgICAgICAgICogICAqIENoYW5nZSB0aGUgZW50aXJlIEFQSSBvZiBtYWtlciBmcm9tIGEgc2luZ2xlIGNvbnN0cnVjdG9yIHRvXG4gICAgICAgICAgICogICAgIHByb3ZpZGluZyBhIE1ha2VyRmFjdG9yeVxuICAgICAgICAgICAqL1xuICAgICAgICAgIG1ha2VyLnByZXBhcmVDb25maWcodGFyZ2V0QXJjaCk7XG4gICAgICAgICAgY29uc3QgYXJ0aWZhY3RzID0gYXdhaXQgbWFrZXIubWFrZSh7XG4gICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgZm9yZ2VDb25maWcsXG4gICAgICAgICAgICBwYWNrYWdlSlNPTixcbiAgICAgICAgICAgIHRhcmdldEFyY2gsXG4gICAgICAgICAgICBkaXI6IHBhY2thZ2VEaXIsXG4gICAgICAgICAgICBtYWtlRGlyOiBwYXRoLnJlc29sdmUoYWN0dWFsT3V0RGlyLCAnbWFrZScpLFxuICAgICAgICAgICAgdGFyZ2V0UGxhdGZvcm06IGFjdHVhbFRhcmdldFBsYXRmb3JtLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgb3V0cHV0cy5wdXNoKHtcbiAgICAgICAgICAgIGFydGlmYWN0cyxcbiAgICAgICAgICAgIHBhY2thZ2VKU09OLFxuICAgICAgICAgICAgcGxhdGZvcm06IGFjdHVhbFRhcmdldFBsYXRmb3JtLFxuICAgICAgICAgICAgYXJjaDogdGFyZ2V0QXJjaCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogYEFuIGVycm9yIG9jY3VyZWQgd2hpbGUgbWFraW5nIGZvciB0YXJnZXQ6ICR7bWFrZXIubmFtZX1gLFxuICAgICAgICAgICAgICBzdGFjazogYCR7ZXJyLm1lc3NhZ2V9XFxuJHtlcnIuc3RhY2t9YCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW4gdW5rbm93biBlcnJvciBvY2N1cmVkIHdoaWxlIG1ha2luZyBmb3IgdGFyZ2V0OiAke21ha2VyLm5hbWV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGUgcG9zdE1ha2UgaG9va3MgbW9kaWZpZXMgdGhlIGxvY2F0aW9ucyAvIG5hbWVzIG9mIHRoZSBvdXRwdXRzIGl0IG11c3QgcmV0dXJuXG4gIC8vIHRoZSBuZXcgbG9jYXRpb25zIHNvIHRoYXQgdGhlIHB1Ymxpc2ggc3RlcCBrbm93cyB3aGVyZSB0byBsb29rXG4gIHJldHVybiBydW5NdXRhdGluZ0hvb2soZm9yZ2VDb25maWcsICdwb3N0TWFrZScsIG91dHB1dHMpO1xufTtcbiJdfQ==